<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · IntervalConstraintProgramming.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><h1>IntervalConstraintProgramming.jl</h1><form class="search" action="search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Home</a><ul class="internal"><li><a class="toctext" href="#Usage-1">Usage</a></li><li><a class="toctext" href="#Set-inversion:-finding-the-feasible-set-1">Set inversion: finding the feasible set</a></li><li><a class="toctext" href="#Set-operations-1">Set operations</a></li><li><a class="toctext" href="#Author-1">Author</a></li><li><a class="toctext" href="#References:-1">References:</a></li><li><a class="toctext" href="#Acknowledements-1">Acknowledements</a></li></ul></li><li><a class="toctext" href="api.html">API</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Home</a></li></ul><a class="edit-page" href="https://github.com/dpsanders/IntervalConstraintProgramming.jl/tree/1eeb1133e6c2474844599d2290d0696a35779250/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="IntervalConstraintProgramming.jl-1" href="#IntervalConstraintProgramming.jl-1"><code>IntervalConstraintProgramming.jl</code></a></h1><p>This Julia package allows you to specify a set of <strong>constraints</strong> on real-valued variables, given by (in)equalities, and rigorously calculate inner and outer approximations to the <em>feasible set</em>, i.e. the set that satisfies the constraints.</p><p>This uses interval arithmetic provided by the author&#39;s <a href="https://github.com/dpsanders/ValidatedNumerics.jl"><code>ValidatedNumerics.jl</code></a> package, in particular multi-dimensional <code>IntervalBox</code>es, i.e. Cartesian products of one-dimensional intervals.</p><p>To do this, <em>interval constraint programming</em> is used, in particular the so-called &quot;forward–backward contractor&quot;. This is implemented in terms of <em>separators</em>; see [Jaulin &amp; Desrochers].</p><h2><a class="nav-anchor" id="Usage-1" href="#Usage-1">Usage</a></h2><p>Let&#39;s define a constraint, using the <code>@constraint</code> macro:</p><pre><code class="language-jlcon">julia&gt; using IntervalConstraintProgramming, ValidatedNumerics

julia&gt; S = @constraint x^2 + y^2 &lt;= 1
Separator:
- variables: x, y
- expression: x ^ 2 + y ^ 2 ∈ [-∞, 1]</code></pre><p>It works out automatically that <code>x</code> and <code>y</code> are variables. The macro creates a <code>Separator</code> object, in this case a <code>ConstraintSeparator</code>.</p><p>We now create an initial interval box in the <span>$x$</span>–<span>$y$</span> plane:</p><pre><code class="language-julia">julia&gt; x = y = -100..100   # notation for creating an interval with `ValidatedNumerics.jl`

julia&gt; X = IntervalBox(x, y)</code></pre><p>The <code>@constraint</code> macro defines an object <code>S</code>, of type <code>Separator</code>. This is a function which, when applied to the box <span>$X = x \times y$</span> in the x–y plane, applies two <em>contractors</em>, an inner one and an outer one.</p><p>The inner contractor tries to shrink down, or <em>contract</em>, the box, to the smallest subbox of <span>$X$</span> that contains the part of <span>$X$</span> that satisfies the constraint; the outer contractor tries to contract <span>$X$</span> to the smallest subbox that contains the region where the constraint is not satisfied.</p><p>When <code>S</code> is applied to the box <code>X</code>, it returns the result of the inner and outer contractors:</p><pre><code class="language-julia">julia&gt; inner, outer = S(X);

julia&gt; inner
([-1, 1],[-1, 1])

julia&gt; outer
([-100, 100],[-100, 100])</code></pre><h2><a class="nav-anchor" id="Set-inversion:-finding-the-feasible-set-1" href="#Set-inversion:-finding-the-feasible-set-1">Set inversion: finding the feasible set</a></h2><p>To make progress, we must recursively bisect and apply the contractors, keeping track of the region proved to be inside the feasible set, and the region that is on the boundary (&quot;both inside and outside&quot;). This is done by the <code>pave</code> function, that takes a separator, a domain to search inside, and an optional tolerance:</p><pre><code class="language-julia">julia&gt; using Plots

julia&gt; x = y = -100..100

julia&gt; S = @constraint 1 &lt;= x^2 + y^2 &lt;= 3

julia&gt; paving = pave(S, X, 0.125);</code></pre><p><code>pave</code> returns an object of type <code>Paving</code>. This contains: the separator itself; an <code>inner</code> approximation, of type <code>SubPaving</code>, which is an alias for a <code>Vector</code> of <code>IntervalBox</code>es; a <code>SubPaving</code> representing the boxes on the boundary that could not be assigned either to the inside or outside of the set; and the tolerance.</p><p>We may draw the result using a plot recipe from <code>ValidatedNumerics</code>. Either a single <code>IntervalBox</code>, or a <code>Vector</code> of <code>IntervalBox</code>es (which a <code>SubPaving</code> is) maybe be drawn using <code>plot</code> from <code>Plots.jl</code>:</p><pre><code class="language-julia">julia&gt; plot(paving.inner, c=&quot;green&quot;)
julia&gt; plot!(paving.boundary, c=&quot;gray&quot;)</code></pre><p>The output should look something like this:</p><p><img src="ring.png" alt="Ring"/></p><p>The green boxes have been <strong>rigorously</strong> proved to be contained within the feasible set, and the white boxes to be outside the set. The grey boxes show those that lie on the boundary, whose status is unknown.</p><h3><a class="nav-anchor" id="D-1" href="#D-1">3D</a></h3><p>The package works in any number of dimensions, although it suffers from the usual exponential slowdown in higher dimensions (&quot;combinatorial explosion&quot;); in 3D, it is still relatively fast.</p><p>There are sample 3D calculations in the <code>examples</code> directory, in particular in the <a href="examples/Solid torus.ipynb">solid torus notebook</a>, which uses <a href="https://github.com/JuliaGL/GLVisualize.jl"><code>GLVisualize.gl</code></a> to provide an interactive visualization that may be rotated and zoomed. The output for the solid torus looks like this:</p><p><img src="solid_torus.png" alt="Coloured solid torus"/></p><h2><a class="nav-anchor" id="Set-operations-1" href="#Set-operations-1">Set operations</a></h2><p>Separators may be combined using the operators <code>!</code> (complement), <code>∩</code> and <code>∪</code> to make more complicated sets; see the <a href="examples/Set inversion.ipynb">notebook</a> for several examples.</p><h2><a class="nav-anchor" id="Author-1" href="#Author-1">Author</a></h2><ul><li><p><a href="http://sistemas.fciencias.unam.mx/~dsanders">David P. Sanders</a></p><ul><li><p><a href="http://julia.mit.edu/">Julia lab, MIT</a></p></li><li><p>Departamento de Física, Facultad de Ciencias, Universidad Nacional Autónoma de México (UNAM)</p></li></ul></li></ul><h2><a class="nav-anchor" id="References:-1" href="#References:-1">References:</a></h2><ul><li><p><em>Applied Interval Analysis</em>, Luc Jaulin, Michel Kieffer, Olivier Didrit, Eric Walter (2001)</p></li><li><p>Introduction to the Algebra of Separators with Application to Path Planning, Luc Jaulin and Benoît Desrochers, <em>Engineering Applications of Artificial Intelligence</em> <strong>33</strong>, 141–147 (2014)</p></li></ul><h2><a class="nav-anchor" id="Acknowledements-1" href="#Acknowledements-1">Acknowledements</a></h2><p>Financial support is acknowledged from DGAPA-UNAM PAPIME grants PE-105911 and PE-107114, and DGAPA-UNAM PAPIIT grant IN-117214, and from a CONACYT-Mexico sabbatical fellowship. The author thanks Alan Edelman and the Julia group for hospitality during his sabbatical visit. He also thanks Luc Jaulin and Jordan Ninin for the <a href="http://iamooc.ensta-bretagne.fr/">IAMOOC</a> online course, which introduced him to this subject.</p><footer><hr/><a class="next" href="api.html"><span class="direction">Next</span><span class="title">API</span></a></footer></article></body></html>
