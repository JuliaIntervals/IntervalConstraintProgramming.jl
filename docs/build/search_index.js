var documenterSearchIndex = {"docs":
[{"location":"index.html#IntervalConstraintProgramming.jl-1","page":"Home","title":"IntervalConstraintProgramming.jl","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"This Julia package allows you to specify a set of constraints on real-valued variables, given by (in)equalities, and rigorously calculate inner and outer approximations to the feasible set, i.e. the set that satisfies the constraints.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"This uses interval arithmetic provided by the author's IntervalArithmetic.jl package, in particular multi-dimensional IntervalBoxes, i.e. Cartesian products of one-dimensional intervals.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"To do this, interval constraint programming is used, in particular the so-called \"forward–backward contractor\". This is implemented in terms of separators; see [Jaulin & Desrochers].","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"DocTestSetup = quote\n    using IntervalConstraintProgramming, IntervalArithmetic\nend","category":"page"},{"location":"index.html#Usage-1","page":"Home","title":"Usage","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Let's define a constraint, using the @constraint macro:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"julia> using IntervalConstraintProgramming, IntervalArithmetic\n\njulia> S = @constraint x^2 + y^2 <= 1\nSeparator:\n  - variables: x, y\n  - expression: x ^ 2 + y ^ 2 ∈ [-∞, 1]","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"It works out automatically that x and y are variables. The macro creates a Separator object, in this case a ConstraintSeparator.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"We now create an initial interval box in the x–y plane:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"julia> x = y = -100..100   # notation for creating an interval with `IntervalArithmetic.jl`\n\njulia> X = IntervalBox(x, y)","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"The @constraint macro defines an object S, of type Separator. This is a function which, when applied to the box X = x times y in the x–y plane, applies two contractors, an inner one and an outer one.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"The inner contractor tries to shrink down, or contract, the box, to the smallest subbox of X that contains the part of X that satisfies the constraint; the outer contractor tries to contract X to the smallest subbox that contains the region where the constraint is not satisfied.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"When S is applied to the box X, it returns the result of the inner and outer contractors:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"julia> inner, outer = S(X);\n\njulia> inner\n([-1, 1],[-1, 1])\n\njulia> outer\n([-100, 100],[-100, 100])","category":"page"},{"location":"index.html#Without-using-Macros-1","page":"Home","title":"Without using Macros","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"We can also make an object S, of type Separator or C, of type Contractor without using Macros, for that you need to define variables using ModelingToolkit.jl. Example  ","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"julia> using IntervalConstraintProgramming, IntervalArithmetic, ModelingToolkit\n\njulia> @variables x y\n(x(), y())\n\njulia> S = Separator(x+y<1)\nSeparator:\n  - variables: x, y\n  - expression: x() + y() == [-∞, 1]\n\njulia> C = Contractor(x+y)\n Contractor in 2 dimensions:\n   - forward pass contracts to 1 dimensions\n   - variables: Symbol[:x, :y]\n   - expression: x() + y()","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"While making Separatoror Contractor's object we can also specify variables, like this","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"julia> vars = @variables x y z\n(x(), y(), z())\n\njulia> S = Separator(vars, x+y<1)\nSeparator:\n  - variables: x, y, z\n  - expression: x() + y() == [-∞, 1]\n\njulia> C = Contractor(vars, y+z)\nContractor in 3 dimensions:\n  - forward pass contracts to 1 dimensions\n  - variables: Symbol[:x, :y, :z]\n  - expression: y() + z()","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"We can make objects (of type Separator or Contractor)by just using function name (Note: you have to specify variables explicitly as discussed above when you make objects by using function name). We can also use polynomial function to make objects.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"julia> vars=@variables x y\n(x(), y())\n\njulia> f(a,b)= a+b\nf (generic function with 1 method)\n\njulia> C = Contractor(vars,f)\nContractor in 2 dimensions:\n  - forward pass contracts to 1 dimensions\n  - variables: Symbol[:x, :y]\n  - expression: x() + y()\n\njulia> f(a,b) = a+b <1\nf (generic function with 1 method)\n\njulia> S=Separator(vars, f)\nSeparator:\n  - variables: x, y\n  - expression: x() + y() == [-∞, 1]  \n\njulia> using DynamicPolynomials       #using polynomial functions\n\njulia> pvars = @polyvar x y\n(x, y)\n\njulia> f(a,b) = a + b < 1\np (generic function with 1 method)\n\njulia> S=Separator(pvars, f)\nSeparator:\n  - variables: x, y\n  - expression: x() + y() == [-∞, 1]","category":"page"},{"location":"index.html#BasicContractor-1","page":"Home","title":"BasicContractor","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Objects of type Contractor have four fields (variables, forward, backward and expression), among them data of two fields (forward, backward) are useful (i.e forward and backward functions) for further usage of that object, thats why it is preferred to use an object of type BasicContractor in place of Contractor which only contain these two fields for less usage of memory by unloading all the extra stuff.(Note: Like object of Contractor type,BasicContractor's object will also have all the properties which are discussed above).","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"julia> @variables x y\n(x(), y())\n\njulia> C = BasicContractor(x^2 + y^2)\n Basic version of Contractor","category":"page"},{"location":"index.html#Set-inversion:-finding-the-feasible-set-1","page":"Home","title":"Set inversion: finding the feasible set","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"To make progress, we must recursively bisect and apply the contractors, keeping track of the region proved to be inside the feasible set, and the region that is on the boundary (\"both inside and outside\"). This is done by the pave function, that takes a separator, a domain to search inside, and an optional tolerance:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"julia> using Plots\n\njulia> x = y = -100..100\n\njulia> S = @constraint 1 <= x^2 + y^2 <= 3\n\njulia> paving = pave(S, X, 0.125);","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"pave returns an object of type Paving. This contains: the separator itself; an inner approximation, of type SubPaving, which is an alias for a Vector of IntervalBoxes; a SubPaving representing the boxes on the boundary that could not be assigned either to the inside or outside of the set; and the tolerance.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"We may draw the result using a plot recipe from IntervalArithmetic. Either a single IntervalBox, or a Vector of IntervalBoxes (which a SubPaving is) maybe be drawn using plot from Plots.jl:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"julia> plot(paving.inner, c=\"green\")\njulia> plot!(paving.boundary, c=\"gray\")","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"The output should look something like this:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"(Image: Ring)","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"The green boxes have been rigorously proved to be contained within the feasible set, and the white boxes to be outside the set. The grey boxes show those that lie on the boundary, whose status is unknown.","category":"page"},{"location":"index.html#D-1","page":"Home","title":"3D","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"The package works in any number of dimensions, although it suffers from the usual exponential slowdown in higher dimensions (\"combinatorial explosion\"); in 3D, it is still relatively fast.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"There are sample 3D calculations in the examples directory, in particular in the solid torus notebook, which uses GLVisualize.gl to provide an interactive visualization that may be rotated and zoomed. The output for the solid torus looks like this:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"(Image: Coloured solid torus)","category":"page"},{"location":"index.html#Set-operations-1","page":"Home","title":"Set operations","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Separators may be combined using the operators ! (complement), ∩ and ∪ to make more complicated sets; see the notebook for several examples. Further examples can be found in the repository IntervalConstraintProgrammingNotebooks.","category":"page"},{"location":"index.html#Author-1","page":"Home","title":"Author","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"David P. Sanders\nJulia lab, MIT\nDepartamento de Física, Facultad de Ciencias, Universidad Nacional Autónoma de México (UNAM)","category":"page"},{"location":"index.html#References:-1","page":"Home","title":"References:","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Applied Interval Analysis, Luc Jaulin, Michel Kieffer, Olivier Didrit, Eric Walter (2001)\nIntroduction to the Algebra of Separators with Application to Path Planning, Luc Jaulin and Benoît Desrochers, Engineering Applications of Artificial Intelligence 33, 141–147 (2014)","category":"page"},{"location":"index.html#Acknowledements-1","page":"Home","title":"Acknowledements","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Financial support is acknowledged from DGAPA-UNAM PAPIME grants PE-105911 and PE-107114, and DGAPA-UNAM PAPIIT grant IN-117214, and from a CONACYT-Mexico sabbatical fellowship. The author thanks Alan Edelman and the Julia group for hospitality during his sabbatical visit. He also thanks Luc Jaulin and Jordan Ninin for the IAMOOC online course, which introduced him to this subject.","category":"page"},{"location":"api.html#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"api.html#","page":"API","title":"API","text":"Modules = [IntervalConstraintProgramming]\nOrder   = [:type, :function]","category":"page"},{"location":"api.html#IntervalConstraintProgramming.Separator-Tuple{Any,ModelingToolkit.Operation}","page":"API","title":"IntervalConstraintProgramming.Separator","text":"Create a separator without the use of macros using ModelingToolkit\n\ne.g  vars = @variables x y z S = Separator(vars, x^2+y^2<1) X= IntervalBox(-0.5..1.5, -0.5..1.5, -0.5..1.5) S(X)\n\n\n\n\n\n","category":"method"},{"location":"api.html#IntervalConstraintProgramming.Vol","page":"API","title":"IntervalConstraintProgramming.Vol","text":"N-dimensional Volume with lower and upper bounds\n\n\n\n\n\n","category":"type"},{"location":"api.html#IntervalConstraintProgramming.pave-Union{Tuple{T}, Tuple{N}, Tuple{Separator,Array{IntervalBox{N,T},1},Any}, Tuple{Separator,Array{IntervalBox{N,T},1},Any,Any}} where T where N","page":"API","title":"IntervalConstraintProgramming.pave","text":"pave takes the given working list of boxes and splits them into inner and boundary lists with the given separator\n\n\n\n\n\n","category":"method"},{"location":"api.html#IntervalConstraintProgramming.pave-Union{Tuple{T}, Tuple{N}, Tuple{Separator,IntervalBox{N,T}}, Tuple{Separator,IntervalBox{N,T},Any}, Tuple{Separator,IntervalBox{N,T},Any,Any}} where T where N","page":"API","title":"IntervalConstraintProgramming.pave","text":"pave(S::Separator, domain::IntervalBox, eps)`\n\nFind the subset of domain defined by the constraints specified by the separator S. Returns (sub)pavings inner and boundary, i.e. lists of IntervalBox.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IntervalConstraintProgramming.AbstractContractor","page":"API","title":"IntervalConstraintProgramming.AbstractContractor","text":"Contractor represents a Contractor from mathbbR^N to mathbbR^N. Nout is the output dimension of the forward part.\n\n\n\n\n\n","category":"type"},{"location":"api.html#IntervalConstraintProgramming.CombinationSeparator","page":"API","title":"IntervalConstraintProgramming.CombinationSeparator","text":"CombinationSeparator is a separator that is a combination (union, intersection, or complement) of other separators.\n\n\n\n\n\n","category":"type"},{"location":"api.html#IntervalConstraintProgramming.ConstraintFunction","page":"API","title":"IntervalConstraintProgramming.ConstraintFunction","text":"A ConstraintFunction contains the created forward and backward code\n\n\n\n\n\n","category":"type"},{"location":"api.html#IntervalConstraintProgramming.ConstraintSeparator","page":"API","title":"IntervalConstraintProgramming.ConstraintSeparator","text":"ConstraintSeparator is a separator that represents a constraint defined directly using @constraint.\n\n\n\n\n\n","category":"type"},{"location":"api.html#IntervalConstraintProgramming.GeneratedFunction","page":"API","title":"IntervalConstraintProgramming.GeneratedFunction","text":"A generated function, with the code that generated it\n\n\n\n\n\n","category":"type"},{"location":"api.html#Base.:∩-Tuple{Separator,Separator}","page":"API","title":"Base.:∩","text":"∩(S1::Separator, S2::Separator)\n\nSeparator for the intersection of two sets given by the separators S1 and S2. Takes an iterator of intervals (IntervalBox, tuple, array, etc.), of length equal to the total number of variables in S1 and S2; it returns inner and outer tuples of the same length\n\n\n\n\n\n","category":"method"},{"location":"api.html#IntervalConstraintProgramming.isuniqued-Tuple{Symbol}","page":"API","title":"IntervalConstraintProgramming.isuniqued","text":"Check if a symbol like :a has been uniqued to :_a_1_\n\n\n\n\n\n","category":"method"},{"location":"api.html#IntervalConstraintProgramming.make_forward_function-NTuple{4,Any}","page":"API","title":"IntervalConstraintProgramming.make_forward_function","text":"Generate code for an anonymous function with given input arguments, output arguments, and code block.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IntervalConstraintProgramming.make_symbol-Tuple{Symbol}","page":"API","title":"IntervalConstraintProgramming.make_symbol","text":"Return a new, unique symbol like z3\n\n\n\n\n\n","category":"method"},{"location":"api.html#IntervalConstraintProgramming.process_assignment!-Tuple{FlatAST,Any}","page":"API","title":"IntervalConstraintProgramming.process_assignment!","text":"An assigment is of the form a = f(...). The name a is currently retained. TODO: It should later be made unique.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IntervalConstraintProgramming.process_call!","page":"API","title":"IntervalConstraintProgramming.process_call!","text":"A call is something like +(x, y). A new variable is introduced for the result; its name can be specified     using the new_var optional argument. If none is given, then a new, generated     name is used.\n\n\n\n\n\n","category":"function"},{"location":"api.html#IntervalConstraintProgramming.process_iterated_function!-Tuple{FlatAST,Any}","page":"API","title":"IntervalConstraintProgramming.process_iterated_function!","text":"Processes something of the form (f↑4)(x) (write as \\uparrow<TAB>) by rewriting it to the equivalent set of iterated functions\n\n\n\n\n\n","category":"method"},{"location":"api.html#IntervalConstraintProgramming.unify_variables-Tuple{Any,Any}","page":"API","title":"IntervalConstraintProgramming.unify_variables","text":"Unify the variables of two separators\n\n\n\n\n\n","category":"method"}]
}
